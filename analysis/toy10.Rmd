---
title: "Ten More Toy Data"
author: "Joonsuk Kang"
date: "3/31/2020"
output: html_document
---


# Data and Functions

### Data

Ten more toy data sets are created in matlab and imported. The data is generated by the same code ("MakeAlign.m") which generated the original toy data: "align300_q10.mat". The code for simulating 10 sets is "code/generate_toydata/JK_create10sets.m".

```{r}
library(R.matlab)

#df <- readMat("/Users/joon/Box/06-GaltonRevisited/1_research/aaint/data/toy10.mat")
df <- readMat("data/toy10.mat")
df <- df$toy10
```


### Functions

```{r}
library(tidyverse); library(pheatmap); library(flashier); library(gridExtra)

fit_data <- function(df, idx){
      
    data.raw <- df[,,idx]
    
    # prepare data
    data.frame(data.raw) %>% mutate_if(is.numeric,as.factor) -> data
    fastDummies::dummy_cols(data, remove_selected_columns=TRUE) -> data
    data <- as.matrix(data)
    col.idx <- matrix(as.numeric(unlist(strsplit(substr(colnames(data),2,100), "_"))), byrow=TRUE, ncol=2)
    
    # fit slashier with point normal prior
    fit <- flashier::flash(data, backfit=TRUE, verbose.lvl = 0, greedy.Kmax = 100, 
                           prior.family = prior.point.normal(),
                           var.type=2) # column-specific error variance
    
    l <- fit$loadings.pm[[1]]
    f <- t(fit$loadings.pm[[2]])
    e <- data - (l %*% f) 
    
    out.list = list(l=l, f=f, e=e, col.idx=col.idx)
    
    return(out.list)
}

# input: L, F, E     where matrix X=LF+E
#        data column index as [position, state] matrix
# output: compressed precision matrix
get_CPM <- function(l,f,e, col.idx){
  
    # exclude first factor (which captures mean level) and loadings for numerical stability
    #apply(l,2,sd) # check standard deviation of the loadings by factors
    l2 <- l[,-1]
    f2 <- f[-1,]
    
    Psi <- cov(e) # error covariance
    Psi.inv <- diag(diag(Psi)^{-1})
    
    Lambda.L <- cov(l2)
    Lambda.L.inv <- diag(diag(Lambda.L)^{-1})
    Omega <- Psi.inv - Psi.inv %*% t(f2) %*% solve(Lambda.L.inv+f2%*%Psi.inv%*%t(f2)) %*% f2 %*% Psi.inv
  
    # measure position i -- position j interaction as sqrt(sum of squares of Omega_{k, l})
    #         where position(k)=i and position(l)=j
    
    data.frame(value = c(Omega),
               position1 = rep(col.idx[,1], times=nrow(col.idx)),
               position2 = rep(col.idx[,1], each=nrow(col.idx))
               ) %>%
      group_by(position1, position2) %>%
      summarise(value = sqrt(sum(value^2))) -> sumsq
    
    # compressed precision matrix
    matrix(sumsq$value, byrow=FALSE, 
           ncol=length(unique(col.idx[,1])) # = number of positions
           ) -> CPM
    
    return(CPM)
}

# input: compressed precision matrix (output from `get_CPM`), 
#        cutoff: to make the figure to easy to check, do not show cells with values < cutoff
# output: heatmap of compressed precision matrix (dim = #positions X #positions)

plot_CPM <- function(CPM, cutoff=0, type=1){
  
    # plot only off-diagonal elements (otherwise, diagonal elements dominate visually)
    diag(CPM) <- NA
    CPM[CPM<cutoff] <- NA
    
    if(type==1){pheatmap(CPM, cluster_rows=FALSE, cluster_cols=FALSE,
             main="Compressed Precision Matrix", display_numbers=TRUE)}
    if(type==2){pheatmap(sqrt(CPM), cluster_rows=FALSE, cluster_cols=FALSE,
              main="Compressed Precision Matrix: sqrt transformed")}
    if(type==3){pheatmap(log(CPM), cluster_rows=FALSE, cluster_cols=FALSE,
                    main="Compressed Precisoin Matrix: log transformed")}
}
```

# CPM of the ten more toy data

Using flashier with point normal prior, compressed precision matrices are estimated. The esitmation differs significantly by input data. On average, the size-4 group has the strongest signal (around 0.45), and the size-6 group and pairwise interactions have similarly weaker signal (around 0.3). In terms of variability, bigger group is more stable: size-6 group has mean absolute deviation 0.03, size-4 group 0.07, pairwise interactions 0.11.

This phenomenon seems to come from the intrinsic difficulty of the problem with small sample size (300), rather than from the specific algorithm (`flash` or `flahsier`) because the result for original toy data was similar to the results from other methods such as pseudolikelihood-based ones (reported by Yaakov).

Our main result for the representative toy data "align300_q10.mat" showed strong signals in size-4 group and pairwise interactions and weaker signal for the size-6 group. Now it seems that the data was a realization of the data generating process which happened to have a big positive signal for the pairwise interactions.

The number of factors allowed was set to 100. For the ten runs, the maximum case was 47. 


### Ten Figures

```{r, fig.width=12, fig.height=9}
# calculate 10 CPM
CPM <- array(0, dim=c(20,20,10))
for (i in 1:10){
  fit <- fit_data(df, i)
  CPM[,,i] <- get_CPM(fit$l, fit$f, fit$e, fit$col.idx)
  print(dim(fit$f)[1]) # number of factors estimated
}
for (i in 1:10){ diag(CPM[,,i]) <- NA} 

# ten CPM plots
plot_list=list()
for (i in 1:10){
  temp.fig <- pheatmap(CPM[,,i], cluster_rows=FALSE, cluster_cols=FALSE, silent=TRUE)
  plot_list[[i]] = temp.fig[[4]] 
}
g <- grid.arrange(arrangeGrob(grobs= plot_list,ncol=4))
```

### Average and Mean Absolute Deviation of Cell Values
```{r, fig.width=7, fig.height=7}
# average CPM
CPMavg <- matrix(0, ncol=20, nrow=20)
for (i in 1:10){CPMavg <- CPMavg + CPM[,,i]/10}
diag(CPMavg) <- NA
pheatmap(CPMavg, cluster_rows=FALSE, cluster_cols=FALSE, display_numbers=TRUE,
         main="Average of Ten Compressed Precision Matrix")

# MAD (mean absolute deviation)
CPMmad <- matrix(0, ncol=20, nrow=20)
for (i in 1:10){CPMmad <- CPMmad + abs(CPMavg-CPM[,,i])/10}
diag(CPMmad) <- NA
pheatmap(CPMmad, cluster_rows=FALSE, cluster_cols=FALSE, display_numbers=TRUE,
         main="Mean Absolute Deviation of Ten Compressed Precision Matrix")
```

